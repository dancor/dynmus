Right now I can play sine waves and such generated by Netwire
through OpenAL.  My main current use is for a dynamic metronome.

# Terminology

* A note is what a piano key corresponds to.
  C4 is a note. B#3 and C4 are the same note.
* A pitch-class is a note without a specified octave.
  C and C# are pitch-classes. C# and Db are the same pitch-class.
  The notes C3 and C4 have the same pitch-class, C.
* A chord-quality is a set of pitch-classes, but two chord-qualities are
  the same if one is a transposition of the other.
  * The 7 "modern Western modes" (from "ionian" to "locrian") all have the
    same chord-quality, that of "major key without a mode chosen".
  * {C,E,G} and {C,F,A} are the same as chord-qualities;
    both are "Maj without a specified inversion".
  * "Maj all inversions" and "min all inversions" are distinct chord-qualities.
* A mode-quality is a chord-quality with one pitch-class designated the "bass".
  In the following comma-delimited sequences the first pitch-class is the bass:
  * The 7 "modern Western modes" (from "ionian" to "locrian") are 7 distinct
  mode-qualities.
  * C,E,G and C,G,E are the same as mode-qualities; this is "Maj".
  * E,C,G is distinct however; it is "Maj6" or "Maj first inversion".
  * C,E,G and F,A,C are the same as mode-qualities; both are "Maj".

# Todo

* I can sometimes hear a bit of warbling in some metronome uses.
  I need to figure out what might be the cause.
* I would like to try again to switch from OpenAL to PortAudio,
  but the current Haskell PortAudio binding is buggy, and I'm
  not terribly experienced with the FFI.

# Past changes

* Switched from Yampa to Netwire since Yampa
is poorly documented, feels caught in an unfinished state,
and is not currently developed.
Netwire started as a fork of Yampa and seems to have
left behind a lot of Yampa's uncertainly by developing its
own stuff based on (<|>).

# Old stuff

plan
* dynamic music
  * possibly eventually for game integration
  * but hopefully still an external somewhat-general library?
* probabilistic
  * and "totally random" possibly even decent fallback, if all other
    computation not ready in time etc
* slider kinds of inputs?
  * what will these look like
    * mood
      * sad vs happy
    * simple vs complex?
    * tonal vs atonal?
    * consonant vs dissonant?
    * eerieness?
    * intensity?
    * general speed
    * meter
* grammar of tonal harmony progressions and transpositions?
* should try to build on what it has played
  * try to have reuse things to be interesting and musical
    * sequences
    * formats, more or less strict
      * can't be too strict to fit into probabilistic model
      * fugue?
  * try to use strategies from human improv technique?
    * nothing should seem like an accident
    * but improvisers
* make use of compositional techniques
  * again, sequences
* lots of things are hard
  * e.g. when are long silences ok
    (after cadences etc..)

sound libraries
* c
  * libsox
    * primarily: read and write different formats
    * apply various effects
    * play and record
  * portaudio
    * primarily: c callback -> play
    * play and record (raw audio only)
  * csound
    * simple music programming system
    * instruments _then_ notes
      * so not going to work with dynamic instruments
      * but maybe modifiable or lib bindings can already be more flex?
    * lots of contributed instrumentation
  * supercollider
    * more advanced programming system than csound
    * so probably just overhead if wrapping in hs frontend stuff?  idk..
* haskell
  * haskore
    * large (slow?) library for representing music
  * hamusic
    * more lightweight alternative to haskore?
